
# 반복자(Iterator)

- 컬렉션의 요소들의 기본 표현​(리스트, 스택, 트리 등)​을 노출하지 않고 그들을 하나씩 순회할 수 있도록 하는 행동 디자인 패턴
> 컬렉션은 다양한 방법(링크드 리스트, 배열, 해시맵, 트리 등)으로 저장한다. 이를 순회하기 위한 방법도 다 다른데, 이것을 클라이언트에서 직접한다면 코드가 매우 복잡해질 것이고, 자료구조가 바뀔 때 마다 대수술이 일어날 것이다. 이를 순회하는 인터페이스를 별도 개체로 추출함으로써 문제를 해결 할 수 있다

# 구조
- Aggregate (인터페이스) : ConcreateIterator 객체를 반환하는 인터페이스를 제공한다.
- ConcreateAggregate (클래스) : 여러 요소들이 이루어져 있는 데이터 집합체
- Iterator (인터페이스) : 집합체 내의 요소들을 순서대로 검색하기 위한 인터페이스를 제공한다.
- ConcreateIterator (클래스) : 반복자 객체
> ConcreateAggregate가 구현한 메서드로부터 생성되며, ConcreateAggregate 의 컬렉션을 참조하여 순회한다.

# 장점
- 일관된 이터레이터 인터페이스를 사용해 여러 형태의 컬렉션에 대해 동일한 순회 방법을 제공한다
- 컬렉션의 내부 구조 및 순회 방식을 알지 않아도 된다
- 집합체의 구현과 접근하는 처리 부분을 반복자 객체로 분리해 결합도를 줄일 수 있다
- 순회 알고리즘을 별도의 반복자 객체에 추출하여 각 클래스의 책임을 분리하여 단일 책임 원칙을 준수한다
- 데이터 저장 컬렉션 종류가 변경되어도 클라이언트 구현 코드는 손상되지 않아 수정에는 닫혀 있어 개방 폐쇄 원칙을 준수한다.

# 단점
- 클래스가 늘어나고 복잡도가 증가한다
- 만일 앱이 간단한 컬렉션에서만 작동하는 경우 패턴을 적용하는 것은 복잡도만 증가할 수 있다
- 이터레이터 객체를 만드는 것이 유용한 상황인지 판단할 필요가 있다
- 구현 방법에 따라 캡슐화를 위배할 수 있다

# 참고

|내용|URL|
|:---|:---|
|반복자 패턴|https://ko.wikipedia.org/wiki/%EB%B0%98%EB%B3%B5%EC%9E%90_%ED%8C%A8%ED%84%B4|
|반복자 패턴|https://refactoring.guru/ko/design-patterns/iterator|