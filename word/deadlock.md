# 교착 상태(Deadlock)
- 잘못된 자원 관리로 인하여 둘 이상의 프로세스 또는 스레드들이 아무것도 진행하지 않는 상태로 서로 영원히 대기하는 상황
> 주로 한정된 자원을 여러 프로세스에서 동시에 사용하는 환경에서 서로 상대방이 사용 중인 자원을 쓰기 위해 대기하는 상황, 그러니까 A가 B를 기다리고 B가 A를 기다릴 때 발생

# 발생조건
- 상호 배제 (Mutual exclusion)
- 점유 상태로 대기 (Hold and wait)
- 선점 불가 (No preemption)
- 순환성 대기 (Circular wait)

# 상호 배제
- 프로그램이 자원을 점유하는 데 있어서 배타적이다. 즉 자원 자체를 동시에 쓸 수 없으며, 반드시 한 번에 하나의 프로세스만이 해당 자원을 사용할 수 있는 경우를 일컫는다. 일반적으로 가변성(mutable) 자원이 이 경우에 속한다.
> 상호 배제가 없다면 (즉, 자원을 여럿이서 동시에 써도 되는 경우라면) 애시당초에 교착 상태는 발생하지 않는다.
> But 프린터 등의 일부 입출력 장치나 연산 결과를 저장하는 변수와 같이 동시에 건드리면 위험한 자원들이 있어, 상호 배제 그 자체를 없애는 것은 불가능

# 점유 상태로 대기
- 자원 하나를 붙잡은 상태에서 또 다른 자원을 기다리는 것. 2개 이상의 자원을 동시에 써야 하는데 이걸 순차적으로 할당받을 경우 몇 개는 이미 할당이 끝났는데 남은 자원을 다른 프로세스가 잡고 있는 것
> 점유 상태로 대기하는 일이 없다면 기다리고 있는 프로세스는 다른 자원을 갖고 있지 않으므로 순환성 대기가 발생할 수 없게 된다

# 선점 불가
- 다른 프로세스가 자원을 가지고 있을 때 이 자원을 가져 올 방법이 없는 것
> 우선순위 선점이 가능해진다면 우선순위가 높은 프로세스가 낮은 프로세스를 중단시키고 작업을 할 수 있지만 운영체제가 아닌 일반 프로세스는 서로 우선순위 선점이 어렵기 때문에 이런 해결 방식은 운영체재 수준이 아니라면 힘들다

# 순환성 대기
- 모든 프로세스가 다른 프로세스가 사용중인 있는 자원을 기다리는 상황에서, 마지막 프로세스가 첫 프로세스가 사용 중인 자원을 쓰기 위해 대기중인 상황

# 대표적인 예
- 식사하는 철학자 문제

# 해결방법
- 예방 (Prevention) : '상호 배제의 부정' 또는 '점유 및 대기 부정', '비선점 부정', '순환 대기 부정' 등이 있다
- 회피 (Avoidance) : 각 요청을 운영체제가 직접 분석함으로써 데드락이 발생할 가능성이 확인하는 방식
- 탐지 (Detection) : 데드락을 막는 것이 아닌 데드락이 필연적으로 발생할 것을 가정하고, 현재 시스템상에서 어느 부분에 데드락이 발생했는지를 탐색
- 복구 (Recovery) : 프로세스 종료, 강제 자원 회수

# 참고

|내용|URL|
|:---|:---|
|데드락|https://namu.wiki/w/%EB%8D%B0%EB%93%9C%EB%9D%BD|